## 어댑터 패턴
- 서로 다른 인터페이스를 가진 클래스들이 함께 동작할 수 있도록 변환해주는 패턴
- 호환되지 않는 인터페이스를 변환하여 기존 코드 변경 없이 사용할 수 있게 함

</br></br>

### 특징
- 기존 코드 변경 없이 새로운 인터페이스 적용 가능
- 클래스 어댑터와 객체 어댑터 두 가지 방식이 있음
- 레거시 시스템과 신규 시스템 간의 연결을 원활하게 지원
- 인터페이스 변환을 통해 코드 재사용성을 높임

</br></br>

### 장단점
장점
1. 기존 코드 변경 없이 새로운 기능 통합 가능 (OCP)
2. 레거시 코드와 호환 가능
3. 클래스 간 의존성을 줄일 수 있음
4. 기본 비즈니스 로직에서 인터페이스 또는 데이터 변환 코드를 분리할 수 있음 (SRP)

단점
1. 어댑터 클래스가 많아지면 코드 복잡도가 증가
2. 어댑터가 중간 계층 역할을 하므로 성능 오버헤드 발생 가능
3. 새 인터페이스가 추가될 때마다 어댑터를 추가해야 함

</br></br>

### 사용 사례
- 레거시 시스템과 신규 시스템 연동
  - 기존 시스템이 지원하지 않는 새로운 인터페이스를 연결할 때 
- API 변환
  - 다른 라이브러리의 API 호출 방식을 변환하여 사용 </br>
    ex. 외부 API와 내부 서비스의 인터페이스 맞추기
- 파일 포맷 변환
  - XML과 JSON 변환 등 데이터 포맷을 변환 

</br></br>

### 구현 방식
1. 클래스 기반
- 기존 클래스의 인터페이스를 새로운 인터페이스로 변환
- 다중 상속 활용 (Java에서는 extends로 구현)
```java
class System {
	public void request() {
		System.out.println("기존 시스템 요청");
	}
}

interface NewSystem {
	void newRequest();
}

class ClassAdapter extends System implements NewSystem {
	@Override
	public void newRequest() {
		request(); 
	}
}

public class Main {
	public static void main(String[] args) {
		NewSystem adapter = new ClassAdapter();
		adapter.newRequest();
	}
}
```

- 기존 System 클래스를 상속하여 새로운 NewSystem 인터페이스를 구현
- 다중 상속을 지원하는 언어에서는 유용하나, Java에서는 단일 상속만 가능하기 때문에 제한적임

<br>

2. 객체 기반
- 어댑터가 기존 클래스를 포함하여 메서드를 호출
- 상속보다 유연하며, 기존 클래스 변경 없이 사용 가능
```java
class System {
	public void request() {
		System.out.println("기존 시스템 요청");
	}
}

interface NewSystem {
	void newRequest();
}

class ObjectAdapter implements NewSystem {
	private System system;

	public ObjectAdapter(System system) {
		this.system = system;
	}

	@Override
	public void newRequest() {
		system.request();
	}
}

public class Main {
    public static void main(String[] args) {
		System system = new System();
        NewSystem adapter = new ObjectAdapter(system);
        adapter.newRequest();
  }
}
```
- 기존 클래스를 상속하는게 아니라 포함하기 때문에 더 유연함
- 기존 클래스 수정 없이 새로운 기능 추가 가능
- 객체를 주입받아 사용하므로 테스트가 쉬움
- 객체 참조가 필요하므로 약간의 성능 오버헤드 발생

<br>

### 빨간약

- Spring에서는 직접 어댑터를 구현하지 않아도 되는 경우가 많다
- @Configuration + @Bean 조합을 사용하여 객체 변환 가능
  - 스프링 컨테이너를 통해 객체를 생성하고 필요한 변환이나 초기화 수행 가능
- Converter, HandlerAdapter, Feign Client, Spring Security Adapter 같은 스프링 내장 기능 활용 가능
  - Converter<S, T> 를 활용하여 타입 간 변환을 간편하게 처리 <br>
    ex. String을 enum으로 변환
  - Spring MVC HandlerAdapter 는 다양한 컨트롤러 타입(@RequestMapping 등)을 자동으로 처리
  - Feign Client는 외부 API 호출 시 인터페이스를 정의하고 일관된 방식으로 API를 호출할 수 있게 하는 어댑터 역할을 함
  

<br>

### 다른 디자인 패턴과의 차이

  **브릿지  vs 어댑터**
- **브릿지 - 사전에 설계**, 여러 다양한 부분을 **독립적으로 개발**
- **어댑터 - 기존 코드에 적용**, **호환되지 않는 클래스를 연결**

| 패턴 | 특징                          |
|------|-----------------------------|
| **브리지** | 인터페이스와 구현을 분리하여 독립적으로 확장 가능 |
| **어댑터** | 기존 객체의 인터페이스를 변환하여 호환되도록 함  |

---

**데코레이터  vs 어댑터**
- **어댑터는 객체의 인터페이스를 변경**
- **데코레이터는 인터페이스를 변경하지 않고 기능을 추가**
- **데코레이터는 재귀적 합성 가능**, **어댑터는 불가능**

| 패턴 | 특징 |
|------|------|
| **데코레이터** | 인터페이스를 유지하면서 기능을 추가할 수 있음 (재귀적 합성 가능) |
| **어댑터** | 인터페이스를 변환하여 기존 코드와 호환되도록 함 |

---

**프록시  vs 어댑터**
- **어댑터는 인터페이스를 변환**,
- **프록시는 기존 인터페이스를 유지하면서 접근을 제어하는 역할**

| 패턴 | 특징                                    |
|------|---------------------------------------|
| **프록시** | 기존 인터페이스를 유지하면서 접근 제어 (ex. 캐싱, 권한 검사) |
| **어댑터** | 기존 객체의 인터페이스를 변환하여 호환성을 높임            |

---

**파사드  vs 어댑터**
- **어댑터는 기존 인터페이스를 변환**하여 사용
- **파사드는 새로운 인터페이스를 정의하여 여러 객체를 단순하게 관리**
- **파사드는 하위 시스템 전체와 관련있지만, 어댑터는 하나의 객체와만 연관 됨**

| 패턴      | 특징                           |
|---------|------------------------------|
| **파사드** | 복잡한 하위 시스템을 단순화하는 새 인터페이스 제공 |
| **어댑터** | 기존 인터페이스를 변환하여 사용 가능하도록 함    |

---

**전략 , 상태 , 브리지  vs 어댑터**
- **모두 객체 합성을 기반으로 다른 객체에 작업을 위임하는 공통 구조를 가짐**.
- 하지만 해결하는 문제가 다름:

| 패턴       | 해결하는 문제 |
|----------|--------------|
| **전략**  | 런타임에 알고리즘을 변경할 수 있도록 함 |
| **상태**  | 객체의 상태에 따라 행동을 변경할 수 있도록 함 |
| **브리지** | 인터페이스와 구현을 분리하여 독립적으로 확장 가능 |
| **어댑터** | 기존 객체의 인터페이스를 변환하여 호환 가능하게 함 |

---

**요약**
- **어댑터**는 **인터페이스를 변환하는 역할**
- **데코레이터는 기능 추가**, **프록시는 접근 제어**, **퍼사드는 구조 개선**, **브리지는 독립적 확장**이 목적
- **전략, 상태, 브리지 패턴은 객체 합성을 기반으로 하지만, 문제 해결 방식이 다름**

어댑터 패턴은 기존 인터페이스를 수정할 수 없을 때, 다른 패턴들과 함께 사용될 수 있는 변환 패턴 
